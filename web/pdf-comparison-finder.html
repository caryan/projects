<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDF Comparison Tool</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            line-height: 1.6;
        }
        .drop-area {
            border: 2px dashed #ccc;
            border-radius: 8px;
            padding: 40px;
            text-align: center;
            margin: 20px 0;
            background-color: #f9f9f9;
            cursor: pointer;
        }
        .drop-area.active {
            border-color: #007bff;
            background-color: #e6f3ff;
        }
        .progress-container {
            margin: 20px 0;
            display: none;
        }
        .progress-bar {
            height: 20px;
            background-color: #e0e0e0;
            border-radius: 10px;
            position: relative;
            overflow: hidden;
        }
        .progress {
            height: 100%;
            background-color: #4CAF50;
            width: 0%;
            border-radius: 10px;
            transition: width 0.3s;
        }
        .progress-text {
            text-align: center;
            margin-top: 5px;
        }
        .duplicate-groups {
            margin-top: 30px;
        }
        .group {
            margin-bottom: 30px;
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 15px;
            background-color: #f9f9f9;
        }
        .unique-group {
            margin-bottom: 30px;
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 15px;
            background-color: #f8f8ff;
        }
        .group-title {
            margin-top: 0;
            padding-bottom: 10px;
            border-bottom: 1px solid #eee;
        }
        .section-header {
            margin-top: 30px;
            margin-bottom: 15px;
            font-size: 1.3em;
            font-weight: bold;
            color: #444;
        }
        .thumbnails {
            display: flex;
            flex-wrap: wrap;
            margin-top: 15px;
        }
        .thumbnail-container {
            margin: 10px;
            text-align: center;
        }
        .thumbnail {
            max-width: 150px;
            max-height: 200px;
            border: 1px solid #ddd;
            border-radius: 3px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        .page-number {
            margin-top: 5px;
            font-size: 0.9em;
        }
        .file-info {
            margin-top: 10px;
            font-style: italic;
        }
        .hidden {
            display: none;
        }
        .file-containers {
            display: flex;
            justify-content: space-between;
            margin-bottom: 20px;
        }
        .file-container {
            width: 48%;
        }
        .comparison-header {
            margin-top: 40px;
            margin-bottom: 20px;
            text-align: center;
            font-size: 1.5em;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <h1>PDF Comparison Tool</h1>
    
    <p>Upload two PDF files to find duplicate pages and sections between them</p>
    
    <div class="file-containers">
        <div class="file-container">
            <div class="drop-area" id="drop-area-1">
                <p>Drag and drop first PDF file here or click to select</p>
                <input type="file" id="file-input-1" accept=".pdf" class="hidden">
            </div>
            <div id="file-info-1" class="file-info"></div>
        </div>
        
        <div class="file-container">
            <div class="drop-area" id="drop-area-2">
                <p>Drag and drop second PDF file here or click to select</p>
                <input type="file" id="file-input-2" accept=".pdf" class="hidden">
            </div>
            <div id="file-info-2" class="file-info"></div>
        </div>
    </div>
    
    <div class="progress-container" id="progress-container">
        <div class="progress-bar">
            <div class="progress" id="progress"></div>
        </div>
        <div class="progress-text" id="progress-text">Processing page 0 of 0...</div>
    </div>
    
    <div class="duplicate-groups" id="duplicate-groups">
        <!-- Results will be displayed here -->
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.min.js"></script>
    <script>
        // Configure PDF.js worker
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.worker.min.js';
        
        // DOM elements
        const dropArea1 = document.getElementById('drop-area-1');
        const fileInput1 = document.getElementById('file-input-1');
        const fileInfo1 = document.getElementById('file-info-1');
        const dropArea2 = document.getElementById('drop-area-2');
        const fileInput2 = document.getElementById('file-input-2');
        const fileInfo2 = document.getElementById('file-info-2');
        const progressContainer = document.getElementById('progress-container');
        const progressBar = document.getElementById('progress');
        const progressText = document.getElementById('progress-text');
        const duplicateGroups = document.getElementById('duplicate-groups');
        
        // State variables for file storage
        let file1 = null;
        let file2 = null;
        
        // Event listeners for drag and drop for first file area
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            dropArea1.addEventListener(eventName, preventDefaults, false);
        });
        
        // Event listeners for drag and drop for second file area
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            dropArea2.addEventListener(eventName, preventDefaults, false);
        });
        
        function preventDefaults(e) {
            e.preventDefault();
            e.stopPropagation();
        }
        
        // Highlight effects for first file area
        ['dragenter', 'dragover'].forEach(eventName => {
            dropArea1.addEventListener(eventName, () => highlight(dropArea1), false);
        });
        
        ['dragleave', 'drop'].forEach(eventName => {
            dropArea1.addEventListener(eventName, () => unhighlight(dropArea1), false);
        });
        
        // Highlight effects for second file area
        ['dragenter', 'dragover'].forEach(eventName => {
            dropArea2.addEventListener(eventName, () => highlight(dropArea2), false);
        });
        
        ['dragleave', 'drop'].forEach(eventName => {
            dropArea2.addEventListener(eventName, () => unhighlight(dropArea2), false);
        });
        
        function highlight(element) {
            element.classList.add('active');
        }
        
        function unhighlight(element) {
            element.classList.remove('active');
        }
        
        // Handle file drops
        dropArea1.addEventListener('drop', (e) => handleDrop(e, 1), false);
        dropArea1.addEventListener('click', () => fileInput1.click(), false);
        fileInput1.addEventListener('change', (e) => handleFileSelect(e, 1), false);
        
        dropArea2.addEventListener('drop', (e) => handleDrop(e, 2), false);
        dropArea2.addEventListener('click', () => fileInput2.click(), false);
        fileInput2.addEventListener('change', (e) => handleFileSelect(e, 2), false);
        
        function handleDrop(e, fileNum) {
            const dt = e.dataTransfer;
            const files = dt.files;
            
            if (files.length > 0 && files[0].type === 'application/pdf') {
                setFile(files[0], fileNum);
            } else {
                alert('Please drop a valid PDF file.');
            }
        }
        
        function handleFileSelect(e, fileNum) {
            const files = e.target.files;
            
            if (files.length > 0 && files[0].type === 'application/pdf') {
                setFile(files[0], fileNum);
            } else {
                alert('Please select a valid PDF file.');
            }
        }
        
        function setFile(file, fileNum) {
            if (fileNum === 1) {
                file1 = file;
                fileInfo1.textContent = `File: ${file.name} (${formatFileSize(file.size)})`;
            } else {
                file2 = file;
                fileInfo2.textContent = `File: ${file.name} (${formatFileSize(file.size)})`;
            }
            
            // If both files are uploaded, start comparison
            if (file1 && file2) {
                compareFiles();
            }
        }
        
        async function compareFiles() {
            // Clear previous results
            duplicateGroups.innerHTML = '';
            
            // Show progress bar
            progressContainer.style.display = 'block';
            
            // Process both PDF files
            const pdf1 = await loadPDF(file1);
            const pdf2 = await loadPDF(file2);
            
            const numPages1 = pdf1.numPages;
            const numPages2 = pdf2.numPages;
            const totalPages = numPages1 + numPages2;
            
            // Update progress text
            progressText.textContent = `Processing page 0 of ${totalPages}...`;
            
            // Create canvas for rendering
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            // Create maps to store page hashes and images for both PDFs
            const pageHashes1 = new Map();
            const pageImages1 = new Map();
            const pageHashes2 = new Map();
            const pageImages2 = new Map();
            
            // Process first PDF
            await processPDF(pdf1, 1, canvas, ctx, pageHashes1, pageImages1, 0, totalPages);
            
            // Process second PDF
            await processPDF(pdf2, 2, canvas, ctx, pageHashes2, pageImages2, numPages1, totalPages);
            
            // Hide progress bar
            progressContainer.style.display = 'none';
            
            // Compare hashes and find duplicates
            findDuplicates(pageHashes1, pageImages1, pageHashes2, pageImages2);
        }
        
        async function loadPDF(file) {
            const arrayBuffer = await file.arrayBuffer();
            return await pdfjsLib.getDocument(arrayBuffer).promise;
        }
        
        async function processPDF(pdf, pdfNum, canvas, ctx, pageHashes, pageImages, offsetPages, totalPages) {
            const numPages = pdf.numPages;
            
            // Process each page
            for (let i = 1; i <= numPages; i++) {
                const page = await pdf.getPage(i);
                
                // Use a high scale for maximum resolution (1.0 is 72 DPI)
                const scale = 1.0;
                const viewport = page.getViewport({ scale: scale });
                
                // Set canvas dimensions to the high-resolution size
                canvas.height = viewport.height;
                canvas.width = viewport.width;
                
                // Render the page at high resolution
                await page.render({
                    canvasContext: ctx,
                    viewport: viewport
                }).promise;
                
                // Get the high-resolution image data at high quality (0.9)
                const highResImageData = canvas.toDataURL('image/jpeg', 0.9);
                
                // Create a lower resolution version for thumbnail display
                const thumbScale = 0.2;
                const thumbViewport = page.getViewport({ scale: thumbScale });
                
                // Create a thumbnail canvas
                const thumbCanvas = document.createElement('canvas');
                thumbCanvas.width = thumbViewport.width;
                thumbCanvas.height = thumbViewport.height;
                const thumbCtx = thumbCanvas.getContext('2d');
                
                // Render the page at thumbnail resolution
                await page.render({
                    canvasContext: thumbCtx,
                    viewport: thumbViewport
                }).promise;
                
                // Get the thumbnail data
                const thumbImageData = thumbCanvas.toDataURL('image/jpeg', 0.8);
                
                // Store the thumbnail for display
                pageImages.set(i, { 
                    image: thumbImageData,
                    pdfNum: pdfNum
                });
                
                // Calculate a hash for the page contents using the high resolution image
                const hash = await calculateImageHash(highResImageData);
                
                // Store the page number by hash
                if (!pageHashes.has(hash)) {
                    pageHashes.set(hash, []);
                }
                pageHashes.get(hash).push(i);
                
                // Update progress
                const progress = ((offsetPages + i) / totalPages) * 100;
                progressBar.style.width = `${progress}%`;
                progressText.textContent = `Processing page ${offsetPages + i} of ${totalPages}...`;
                
                // Small delay to let the UI update
                await new Promise(resolve => setTimeout(resolve, 0));
            }
        }
        
        function findDuplicates(pageHashes1, pageImages1, pageHashes2, pageImages2) {
            // Create a map of duplicate pages between the two PDFs
            const crossDuplicates = new Map();
            
            // Track which pages have been matched across the files
            const matchedPages1 = new Set();
            const matchedPages2 = new Set();
            
            // For each hash in the first PDF
            for (const [hash1, pages1] of pageHashes1.entries()) {
                // Check if the hash exists in the second PDF
                if (pageHashes2.has(hash1)) {
                    const pages2 = pageHashes2.get(hash1);
                    
                    // Record the cross-duplicates
                    for (const page1 of pages1) {
                        if (!crossDuplicates.has(page1)) {
                            crossDuplicates.set(page1, []);
                        }
                        
                        for (const page2 of pages2) {
                            crossDuplicates.get(page1).push(page2);
                            
                            // Mark these pages as matched
                            matchedPages1.add(page1);
                            matchedPages2.add(page2);
                        }
                    }
                }
            }
            
            // Now identify consecutive duplicate sections
            const sectionsMap = new Map();
            const processedPages1 = new Set();
            const processedPages2 = new Set();
            
            // For each page in PDF1 that has a duplicate in PDF2
            for (const [startPage1, duplicatePages2] of crossDuplicates.entries()) {
                // Skip if already processed as part of a section
                if (processedPages1.has(startPage1)) continue;
                
                // For each page in PDF2 that duplicates with the current page in PDF1
                for (const startPage2 of duplicatePages2) {
                    // Skip if already processed as part of a section
                    if (processedPages2.has(startPage2)) continue;
                    
                    // Try to find a consecutive section
                    let sectionLength = 1;
                    let currentPage1 = startPage1;
                    let currentPage2 = startPage2;
                    
                    // Check consecutive pages
                    while (true) {
                        const nextPage1 = currentPage1 + 1;
                        const nextPage2 = currentPage2 + 1;
                        
                        // Check if the next pages exist and form a duplicate pair
                        if (crossDuplicates.has(nextPage1) && 
                            crossDuplicates.get(nextPage1).includes(nextPage2)) {
                            
                            // Extend the section
                            sectionLength++;
                            currentPage1 = nextPage1;
                            currentPage2 = nextPage2;
                            
                            // Mark these pages as processed
                            processedPages1.add(nextPage1);
                            processedPages2.add(nextPage2);
                        } else {
                            break;
                        }
                    }
                    
                    // If we found a section of 2 or more pages or a single page
                    if (sectionLength >= 1) {
                        const sectionKey = `${startPage1}-${startPage1 + sectionLength - 1}`;
                        
                        if (!sectionsMap.has(sectionKey)) {
                            sectionsMap.set(sectionKey, []);
                        }
                        
                        sectionsMap.get(sectionKey).push({
                            start: startPage2,
                            end: startPage2 + sectionLength - 1
                        });
                        
                        // Mark start pages as processed
                        processedPages1.add(startPage1);
                        processedPages2.add(startPage2);
                    }
                }
            }
            
            // Identify unique pages (set differences)
            const uniquePages1 = []; // Pages in PDF1 not in PDF2
            const uniquePages2 = []; // Pages in PDF2 not in PDF1
            
            // Find unique pages in file 1
            for (let i = 1; i <= pageImages1.size; i++) {
                if (!matchedPages1.has(i)) {
                    uniquePages1.push(i);
                }
            }
            
            // Find unique pages in file 2
            for (let i = 1; i <= pageImages2.size; i++) {
                if (!matchedPages2.has(i)) {
                    uniquePages2.push(i);
                }
            }
            
            // Display results
            // Add a comparison header
            const comparisonHeader = document.createElement('div');
            comparisonHeader.className = 'comparison-header';
            comparisonHeader.textContent = `Comparing ${file1.name} with ${file2.name}`;
            duplicateGroups.appendChild(comparisonHeader);
            
            // Display summary statistics
            let duplicateCount = sectionsMap.size;
            
            const summary = document.createElement('p');
            summary.innerHTML = `
                <strong>Summary:</strong><br>
                - ${duplicateCount} duplicate ${duplicateCount !== 1 ? 'sections' : 'section'} found between documents<br>
                - ${uniquePages1.length} unique pages in File 1 (not in File 2)<br>
                - ${uniquePages2.length} unique pages in File 2 (not in File 1)
            `;
            duplicateGroups.appendChild(summary);
            
            // Display duplicate sections
            if (sectionsMap.size > 0) {
                const duplicateHeader = document.createElement('div');
                duplicateHeader.className = 'section-header';
                duplicateHeader.textContent = 'Duplicate Content';
                duplicateGroups.appendChild(duplicateHeader);
                
                let groupCount = 0;
                
                for (const [sectionKey, duplicateSections] of sectionsMap) {
                    groupCount++;
                    
                    const [startPage, endPage] = sectionKey.split('-').map(Number);
                    const sectionLength = endPage - startPage + 1;
                    
                    // Create group element
                    const group = document.createElement('div');
                    group.className = 'group';
                    
                    // Create group title showing the section and its duplicates
                    const groupTitle = document.createElement('h3');
                    groupTitle.className = 'group-title';
                    
                    let titleText = `Duplicate ${sectionLength > 1 ? "Section" : "Page"} ${groupCount}`;
                    titleText += ` - File 1: Page${sectionLength > 1 ? "s" : ""} ${startPage}${sectionLength > 1 ? `-${endPage}` : ""}`;
                    titleText += ` matches File 2: `;
                    
                    const duplicateRanges = duplicateSections.map(section => {
                        const rangeLength = section.end - section.start + 1;
                        return `Page${rangeLength > 1 ? "s" : ""} ${section.start}${rangeLength > 1 ? `-${section.end}` : ""}`;
                    }).join(', ');
                    
                    groupTitle.textContent = titleText + duplicateRanges;
                    group.appendChild(groupTitle);
                    
                    // Create thumbnails container
                    const thumbnails = document.createElement('div');
                    thumbnails.className = 'thumbnails';
                    
                    // Add thumbnails for PDF1 pages
                    for (const pageNum of [startPage, endPage].filter((v, i, a) => i === 0 || a[0] !== a[1])) {
                        const thumbnailContainer = document.createElement('div');
                        thumbnailContainer.className = 'thumbnail-container';
                        
                        const thumbnail = document.createElement('img');
                        thumbnail.className = 'thumbnail';
                        thumbnail.src = pageImages1.get(pageNum).image;
                        thumbnailContainer.appendChild(thumbnail);
                        
                        const pageNumberText = document.createElement('div');
                        pageNumberText.className = 'page-number';
                        pageNumberText.textContent = `File 1: Page ${pageNum}`;
                        thumbnailContainer.appendChild(pageNumberText);
                        
                        thumbnails.appendChild(thumbnailContainer);
                    }
                    
                    // Add thumbnails for PDF2 pages
                    for (const section of duplicateSections) {
                        const pageNums = [section.start, section.end].filter((v, i, a) => i === 0 || a[0] !== a[1]);
                        
                        for (const pageNum of pageNums) {
                            const thumbnailContainer = document.createElement('div');
                            thumbnailContainer.className = 'thumbnail-container';
                            
                            const thumbnail = document.createElement('img');
                            thumbnail.className = 'thumbnail';
                            thumbnail.src = pageImages2.get(pageNum).image;
                            thumbnailContainer.appendChild(thumbnail);
                            
                            const pageNumberText = document.createElement('div');
                            pageNumberText.className = 'page-number';
                            pageNumberText.textContent = `File 2: Page ${pageNum}`;
                            thumbnailContainer.appendChild(pageNumberText);
                            
                            thumbnails.appendChild(thumbnailContainer);
                        }
                    }
                    
                    group.appendChild(thumbnails);
                    duplicateGroups.appendChild(group);
                }
            } else {
                const noResultsMsg = document.createElement('p');
                noResultsMsg.textContent = 'No duplicate pages or sections found between these documents.';
                duplicateGroups.appendChild(noResultsMsg);
            }
            
            // Display unique pages in File 1
            if (uniquePages1.length > 0) {
                const uniqueFile1Header = document.createElement('div');
                uniqueFile1Header.className = 'section-header';
                uniqueFile1Header.textContent = `Pages Unique to File 1 (${file1.name})`;
                duplicateGroups.appendChild(uniqueFile1Header);
                
                const maxThumbnails = 10; // Limit number of thumbnails displayed
                const group = document.createElement('div');
                group.className = 'unique-group';
                
                // Create group title
                const groupTitle = document.createElement('h3');
                groupTitle.className = 'group-title';
                groupTitle.textContent = `${uniquePages1.length} pages only in File 1`;
                group.appendChild(groupTitle);
                
                // Create thumbnails container
                const thumbnails = document.createElement('div');
                thumbnails.className = 'thumbnails';
                
                // Add thumbnails for unique pages (up to max limit)
                const pagesToShow = uniquePages1.length > maxThumbnails ? 
                    uniquePages1.slice(0, maxThumbnails) : uniquePages1;
                
                for (const pageNum of pagesToShow) {
                    const thumbnailContainer = document.createElement('div');
                    thumbnailContainer.className = 'thumbnail-container';
                    
                    const thumbnail = document.createElement('img');
                    thumbnail.className = 'thumbnail';
                    thumbnail.src = pageImages1.get(pageNum).image;
                    thumbnailContainer.appendChild(thumbnail);
                    
                    const pageNumberText = document.createElement('div');
                    pageNumberText.className = 'page-number';
                    pageNumberText.textContent = `Page ${pageNum}`;
                    thumbnailContainer.appendChild(pageNumberText);
                    
                    thumbnails.appendChild(thumbnailContainer);
                }
                
                if (uniquePages1.length > maxThumbnails) {
                    const moreInfo = document.createElement('div');
                    moreInfo.style.marginTop = '10px';
                    moreInfo.textContent = `... and ${uniquePages1.length - maxThumbnails} more pages`;
                    group.appendChild(moreInfo);
                }
                
                // Add page list as text
                const pageList = document.createElement('div');
                pageList.style.marginTop = '10px';
                pageList.textContent = `Pages: ${formatPageRanges(uniquePages1)}`;
                
                group.appendChild(thumbnails);
                group.appendChild(pageList);
                duplicateGroups.appendChild(group);
            }
            
            // Display unique pages in File 2
            if (uniquePages2.length > 0) {
                const uniqueFile2Header = document.createElement('div');
                uniqueFile2Header.className = 'section-header';
                uniqueFile2Header.textContent = `Pages Unique to File 2 (${file2.name})`;
                duplicateGroups.appendChild(uniqueFile2Header);
                
                const maxThumbnails = 10; // Limit number of thumbnails displayed
                const group = document.createElement('div');
                group.className = 'unique-group';
                
                // Create group title
                const groupTitle = document.createElement('h3');
                groupTitle.className = 'group-title';
                groupTitle.textContent = `${uniquePages2.length} pages only in File 2`;
                group.appendChild(groupTitle);
                
                // Create thumbnails container
                const thumbnails = document.createElement('div');
                thumbnails.className = 'thumbnails';
                
                // Add thumbnails for unique pages (up to max limit)
                const pagesToShow = uniquePages2.length > maxThumbnails ? 
                    uniquePages2.slice(0, maxThumbnails) : uniquePages2;
                
                for (const pageNum of pagesToShow) {
                    const thumbnailContainer = document.createElement('div');
                    thumbnailContainer.className = 'thumbnail-container';
                    
                    const thumbnail = document.createElement('img');
                    thumbnail.className = 'thumbnail';
                    thumbnail.src = pageImages2.get(pageNum).image;
                    thumbnailContainer.appendChild(thumbnail);
                    
                    const pageNumberText = document.createElement('div');
                    pageNumberText.className = 'page-number';
                    pageNumberText.textContent = `Page ${pageNum}`;
                    thumbnailContainer.appendChild(pageNumberText);
                    
                    thumbnails.appendChild(thumbnailContainer);
                }
                
                if (uniquePages2.length > maxThumbnails) {
                    const moreInfo = document.createElement('div');
                    moreInfo.style.marginTop = '10px';
                    moreInfo.textContent = `... and ${uniquePages2.length - maxThumbnails} more pages`;
                    group.appendChild(moreInfo);
                }
                
                // Add page list as text
                const pageList = document.createElement('div');
                pageList.style.marginTop = '10px';
                pageList.textContent = `Pages: ${formatPageRanges(uniquePages2)}`;
                
                group.appendChild(thumbnails);
                group.appendChild(pageList);
                duplicateGroups.appendChild(group);
            }
        }
        
        // Helper function to format page numbers into ranges (e.g. 1,2,3,5,6,7 -> 1-3,5-7)
        function formatPageRanges(pages) {
            if (pages.length === 0) return '';
            
            // Make sure pages are sorted
            const sortedPages = [...pages].sort((a, b) => a - b);
            
            const ranges = [];
            let rangeStart = sortedPages[0];
            let rangeEnd = sortedPages[0];
            
            for (let i = 1; i < sortedPages.length; i++) {
                if (sortedPages[i] === rangeEnd + 1) {
                    // Extend the current range
                    rangeEnd = sortedPages[i];
                } else {
                    // End the current range and start a new one
                    if (rangeStart === rangeEnd) {
                        ranges.push(rangeStart.toString());
                    } else {
                        ranges.push(`${rangeStart}-${rangeEnd}`);
                    }
                    
                    rangeStart = sortedPages[i];
                    rangeEnd = sortedPages[i];
                }
            }
            
            // Add the last range
            if (rangeStart === rangeEnd) {
                ranges.push(rangeStart.toString());
            } else {
                ranges.push(`${rangeStart}-${rangeEnd}`);
            }
            
            return ranges.join(', ');
        }
        
        // High-precision PDF page hash function that uses full resolution
        async function calculateImageHash(imageDataUrl) {
            return new Promise((resolve) => {
                const img = new Image();
                img.onload = function() {
                    // Store original aspect ratio
                    const aspectRatio = img.width / img.height;
                    
                    // Create a canvas for the hash - use the original high-resolution size
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    
                    // Use the image's full resolution
                    canvas.width = img.width;
                    canvas.height = img.height;
                    
                    // Draw the image at full resolution
                    ctx.fillStyle = 'white';
                    ctx.fillRect(0, 0, canvas.width, canvas.height); // Fill with white background first
                    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                    
                    // Get the pixel data
                    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    const data = imageData.data;
                    
                    // Convert to grayscale
                    const grayScaleMatrix = new Array(canvas.height * canvas.width);
                    
                    for (let y = 0; y < canvas.height; y++) {
                        for (let x = 0; x < canvas.width; x++) {
                            const pixelIndex = (y * canvas.width + x) * 4;
                            
                            // Convert RGB to grayscale using perceived luminance weights
                            const r = data[pixelIndex];
                            const g = data[pixelIndex + 1];
                            const b = data[pixelIndex + 2];
                            
                            // Weighted grayscale conversion (human eye is more sensitive to green)
                            const grayValue = 0.299 * r + 0.587 * g + 0.114 * b;
                            grayScaleMatrix[y * canvas.width + x] = grayValue;
                        }
                    }
                    
                    // Compute the reduced feature set (maintaining aspect ratio)
                    // Use a higher resolution grid for more precise comparisons
                    const gridHeight = 32; // Higher resolution grid
                    const gridWidth = Math.max(16, Math.round(gridHeight * aspectRatio / 2)); // Ensure at least 16 columns
                    
                    const blockHeight = canvas.height / gridHeight;
                    const blockWidth = canvas.width / gridWidth;
                    
                    const featureValues = new Array(gridHeight * gridWidth);
                    
                    for (let y = 0; y < gridHeight; y++) {
                        for (let x = 0; x < gridWidth; x++) {
                            let blockSum = 0;
                            let pixelCount = 0;
                            
                            // Average each block
                            for (let by = 0; by < blockHeight; by++) {
                                for (let bx = 0; bx < blockWidth; bx++) {
                                    const origX = Math.floor(x * blockWidth + bx);
                                    const origY = Math.floor(y * blockHeight + by);
                                    
                                    if (origX < canvas.width && origY < canvas.height) {
                                        blockSum += grayScaleMatrix[origY * canvas.width + origX];
                                        pixelCount++;
                                    }
                                }
                            }
                            
                            featureValues[y * gridWidth + x] = pixelCount > 0 ? blockSum / pixelCount : 0;
                        }
                    }
                    
                    // Feature extraction using mean and variance of each block
                    const blockFeatures = [];
                    
                    // Calculate both mean and variance for each block for better discrimination
                    for (let y = 0; y < gridHeight; y++) {
                        for (let x = 0; x < gridWidth; x++) {
                            let blockSum = 0;
                            let blockSumSquares = 0;
                            let pixelCount = 0;
                            
                            // First pass: Calculate sum and sum of squares
                            for (let by = 0; by < blockHeight; by++) {
                                for (let bx = 0; bx < blockWidth; bx++) {
                                    const origX = Math.floor(x * blockWidth + bx);
                                    const origY = Math.floor(y * blockHeight + by);
                                    
                                    if (origX < canvas.width && origY < canvas.height) {
                                        const value = grayScaleMatrix[origY * canvas.width + origX];
                                        blockSum += value;
                                        blockSumSquares += value * value;
                                        pixelCount++;
                                    }
                                }
                            }
                            
                            if (pixelCount > 0) {
                                const mean = blockSum / pixelCount;
                                const variance = (blockSumSquares / pixelCount) - (mean * mean);
                                blockFeatures.push({ mean, variance });
                            } else {
                                blockFeatures.push({ mean: 0, variance: 0 });
                            }
                        }
                    }
                    
                    // Calculate overall mean for thresholding
                    const sortedMeans = blockFeatures.map(f => f.mean).sort((a, b) => a - b);
                    const medianValue = sortedMeans[Math.floor(sortedMeans.length / 2)];
                    
                    // Create the hash combining multiple features
                    let hash = '';
                    
                    // Add aspect ratio to the hash with higher precision
                    const aspectRatioQuantized = Math.round(aspectRatio * 100);
                    hash += aspectRatioQuantized.toString(36); // Base36 encoding to keep it compact
                    hash += '_'; // Separator for readability in debugging
                
                    // Add mean-based hash component
                    for (let i = 0; i < blockFeatures.length; i++) {
                        hash += blockFeatures[i].mean > medianValue ? '1' : '0';
                    }
                    hash += '_'; // Separator
                    
                    // Add variance-based hash component (high variance = more texture/detail)
                    const sortedVariances = blockFeatures.map(f => f.variance).sort((a, b) => a - b);
                    const medianVariance = sortedVariances[Math.floor(sortedVariances.length / 2)];
                    
                    for (let i = 0; i < blockFeatures.length; i++) {
                        hash += blockFeatures[i].variance > medianVariance ? '1' : '0';
                    }
                    hash += '_'; // Separator
                    
                    // Add content density features with higher precision
                    let nonWhitePixels = 0;
                    let blackPixels = 0;
                    const totalPixels = canvas.width * canvas.height;
                    
                    for (let i = 0; i < data.length; i += 4) {
                        // Check if pixel is not white (with some tolerance)
                        if (data[i] < 240 || data[i+1] < 240 || data[i+2] < 240) {
                            nonWhitePixels++;
                            
                            // Count very dark pixels separately (text/lines)
                            if (data[i] < 30 && data[i+1] < 30 && data[i+2] < 30) {
                                blackPixels++;
                            }
                        }
                    }
                    
                    // Add both total content and black content percentages
                    const contentDensity = Math.round((nonWhitePixels / totalPixels) * 1000);
                    const blackDensity = Math.round((blackPixels / totalPixels) * 1000);
                    
                    hash += contentDensity.toString(36); // Add content density to hash
                    hash += '_'; // Separator
                    hash += blackDensity.toString(36); // Add black content density
                    
                    resolve(hash);
                };
                img.src = imageDataUrl;
            });
        }
        
        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }
    </script>
</body>
</html>